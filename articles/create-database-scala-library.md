---
title: "Scalaのデータベースライブラリを作った話"
emoji: "🐇"
type: "tech"
topics: ["Scala", "Database", "MySQL", "OSS", "jdbc"]
published: false # 公開設定（falseにすると下書き）
---

## イントロダクション

データベースは、現代のソフトウェア開発において必要不可欠な要素です。
しかし、データベースの管理はソフトウェア開発において必須ながら時に面倒な作業です。
特にデータベーススキーマの管理は開発プロセスのスムーズさを左右する重要な要素ですが、開発者にとって大きな負担となることがあります。
データベーススキーマは、データベースの構造を定義するための設計図であり、開発者がデータベースを操作するための基盤となります。
しかし、そのスキーマを効率的に管理し、開発の様々なフェーズで一貫性を保つことは、かなりの労力を必要とします。

そんな課題を少しでも解消したいという思いから、私は新しくOSSプロジェクトを作成しました。
このプロジェクトは、データベーススキーマをコードで定義し、自動で詳細な仕様書を生成するLDBCという名前のプロジェクトです。

https://github.com/takapi327/ldbc

このアイデアは、API定義からOpenAPIの仕様書を生成してくれる[tapir](https://tapir.softwaremill.com/en/latest/)というOSSからヒントを得ました。私の目標は、この便利さをデータベースの領域にも拡げること。具体的には、テーブル定義からSchemaSPYの仕様書を自動生成し、開発者がデータベース構造をより容易に管理できるようにすることです。

この記事を通じて、プロジェクトの背後にある動機、それが持つユニークな特徴、そして将来どのようにしていきたいかを紹介できればと思います。
Scalaを使ったデータベーススキーマの管理方法や、JVM以外の環境での動作拡張を目指すプロジェクトのビジョンも共有する予定です。

## プロジェクトの特徴と利点

LDBCの主な特徴は以下です。

- 型安全性：コンパイル時の保証、開発時の補完、読み取り時の情報
- 宣言型：テーブル定義の形（“What”）と何かの処理（“How”）を分離する
- SchemaSPYの統合：テーブル記述からドキュメントを生成する
- 自動生成: SQLファイルからコードの生成

それぞれの特徴に関して見ていきます。

### 型安全性：コンパイル時の保証、開発時の補完、読み取り時の情報

LDBCは、Scalaモデルとデータベースのテーブル定義を1対1のマッピングで管理します。モデルが保持するプロパティとテーブルが保持するカラムのマッピングは、定義順に行われます。
テーブル定義は、Create文の構造と非常によく似ています。このため、テーブル定義の構築はユーザーにとって直感的なものとなります。

```scala 3
case class User(
  id: Long,
  name: String,
  age: Option[Int],
)

val table = Table[User]("user")(                     // CREATE TABLE `user` (
  column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY), //   `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
  column("name", VARCHAR(255)),                      //   `name` VARCHAR(255) NOT NULL,
  column("age", INT.UNSIGNED.DEFAULT(None)),         //   `age` INT unsigned DEFAULT NULL
)                                                    // );
```

仮に間違った型を組み合わせようとするとコンパイルエラーになります。
例えば、Userが持つString型のnameプロパティに関連するカラムに、INT型のデータ型を渡すとエラーになります。

```shell
[error] -- [E007] Type Mismatch Error:
[error] 169 |    column("name", INT),
[error]     |                   ^^^
[error]     |Found:    ldbc.core.DataType.Integer[T]
[error]     |Required: ldbc.core.DataType[String]
[error]     |
[error]     |where:    T is a type variable with constraint <: Int | Long | Option[Int | Long]
```

文字列と数値を間違えることはほぼありませんが、MySQLの整数値を扱う上では注意しなければいけないことがあります。
それは、整数値の範囲です。
MySQLの整数値は符号付きと符号なしの2つの範囲があります。
それぞれの範囲は以下の通りであり、符号付きと符号なしではScalaで取り扱える型が異なってきます。

| Data Type | signed range                               | unsigned range           | Scala Type     | range                                                              |
|-----------|--------------------------------------------|--------------------------|----------------|--------------------------------------------------------------------|
| TINYINT   | -128 ~ 127                                 | 0 ~ 255                  | Byte<br>Short  | -128 ~ 127<br>-32768～32767                                         |
| SMALLINT  | -32768 ~ 32767                             | 0 ~ 65535                | Short<br>Int   | -32768～32767<br>-2147483648～2147483647                             |
| MEDIUMINT | -8388608 ~ 8388607                         | 0 ~ 16777215             | Int            | -2147483648～2147483647                                             |
| INT       | -2147483648	~ 2147483647                   | 0 ~ 4294967295           | Int<br>Long    | -2147483648～2147483647<br>-9223372036854775808～9223372036854775807 |
| BIGINT    | -9223372036854775808 ~ 9223372036854775807 | 0 ~ 18446744073709551615 | Long<br>BigInt | -9223372036854775808～9223372036854775807<br>...                    |

アプリケーションとデータベーススキーマを別で管理している場合は、このような範囲の違いを見落とすことがあるかと思います。

LDBCではScalaの型システムを活用することで、このような整数型の範囲の違いもテーブル定義の構築時にエラーを検知できるためデータベースのスキーマをより安全に管理することができます。

他にもIndexやForeignKeyなどの定義もサポートしています。

具体的な実装方法に関しては、以下のドキュメントを参照してください。

https://takapi327.github.io/ldbc/ja/01-Table-Definitions.html

このようにLDBCではScalaの型システムを活用し、データベースのスキーマを型安全にコードで管理することができます。

### 宣言型：テーブル定義の形（“What”）と何かの処理（“How”）を分離する

LDBCは、テーブル定義の形（“What”）と何かの処理（“How”）を分離することで、データベースのスキーマを宣言型で管理します。

テーブル定義の形（“What”）は、テーブル定義をコードで記述することで実現されました。
では、何かの処理（“How”）はどのようなものがあるのでしょうか？

その1つにデータベース接続があります。

LDBCは、データベース接続にJDBCを使用しています。 JDBCはJavaのデータベース接続のための標準的なAPIです。
LDBCはこのJDBCを[Cats Effect](https://typelevel.org/cats-effect/)のEffect Systemで薄くラップしたものを提供しています。

LDBCは作成したテーブル定義を使用して、データベースの操作を行うために必要となるクエリの構築を行う型安全なAPIを提供しています。

以下のようにテーブル定義を`TableQuery`に渡すことで、型安全なAPIを生成することができます。

```scala 3
val user = TableQuery[IO, User](table)
```

例として、型安全にSELECT文を構築する方法はTableQueryが提供するselectメソッドを使用することです。LDBCではプレーンなクエリに似せて実装されているため直感的にクエリ構築が行えます。またどのようなクエリが構築されているかも一目でわかるような作りになっています。

```scala 3
val select = userQuery.select(user => (user.id, user.name))

select.statement === "SELECT `id`, `name` FROM user"
```

これを見てわかる通りLDBCで提供しているAPIは、ORMではなくクエリビルダーです。
ORMは、データベースのテーブルとオブジェクトを1対1でマッピングすることを目的としていますが、LDBCはテーブル定義とクエリの構築を分離しテーブル定義からクエリの構築を行えるようにすることを目的としています。

ここでまず筆者はORMやクエリビルダー、プレーンクエリのどちらが良いかという議論には興味がありません。それぞれのユースケースに合わせて適切なものを選択することが重要ですし、使う人の好みにもよると思います。
筆者自体はプレーンクエリを使用するデータベースライブラリが一番好きです。ですがプレーンクエリにも問題があります。それは、クエリの構築が文字列操作になるため、クエリの構築時にエラーを検知することが難しいことです。
また、クエリの書き方にもよりますがテーブル定義が変わった場合、クエリの構築部分も変更する必要があります。

しかし、プレーンクエリはクエリの構築が文字列操作になるためScalaの型システムによりエラー検知が難しいという問題があります。
例えば、先ほどのUserテーブルから全てのカラム値を取得したいような場合、一番簡単な方法は以下のクエリを使用することです。

```sql
SELECT * FROM user
```

Userテーブルにはid, name, ageの3つのカラムがあり、取得した結果`(String, String, Option[Int])`のタプルが返ってくるもしくは、`User`型にマッピングしているとします。
ここでテーブル定義に、新たにカラムを追加した場合どうなるでしょうか？
`(String, String, Option[Int])`の3つのレコードに合わせて新たに追加したカラムの値が返ってくることになります。
しかし、戻り値の型は`(String, String, Option[Int])`のままです。これをコンパイル時に検知することは難しいです。
このような問題をプレーンクエリでは解決することが難しいです。

このような簡単なクエリで実行時エラーになってしまうのは、Scalaという型安全な言語を使用している上で非常にもったいないことです。

また、Scala界隈？ではなぜかプレーンクエリを使用したライブラリが多く、クエリビルダーやORMを使用したライブラリが少ないです。
筆者の勝手なイメージですが、関数型を好む人はプレーンクエリを好む傾向があり、オブジェクト指向を好む人はORMやクエリビルダーを好む傾向があるのかなと思います。(根拠はありません)

Scalaは関数型言語ですが、関数型言語であるからといって関数型プログラミングをする必要はありません。オブジェクト指向プログラミングをすることもできますし、関数型プログラミングをすることもできます。
関数型を触ったことない人がScalaを触ってみようと思った時にORMやクエリビルダーのライブラリが少ないとちょっと触り難いかなと思いクエリビルダーを提供することにしました。

Cats Effect使ってるからそもそも関数型言語を使っている人が使いやすいようなライブラリじゃないか？という意見もあるかと思います。全くもっておっしゃる通りでございます。。。
ここはライブラリを開発して得た「失敗と学び」で話させていただければと思います。

上記を踏まえて、クエリビルダーを使用することで型安全にクエリを構築しコンパイル時にエラーを検知することができるようにしました。
クエリビルダーなどを使うと実行しているクエリがどのようなものかを一目でわからないという問題がありますが、LDBCではなるべくプレーンクエリに似せて実装することである程度直感的にクエリ構築が行えるようにしました。

ORMにしなかったのは、ORMはライブラリ側がかなり頑張って実装を行わないといけずまた型の安全性を担保するためにライブラリ側のコードがすごく複雑になってしまうと懸念したためです。
また、LDBCは定義と実行を分離したかったためクエリビルダーでクエリ構築のみを行いデータベース接続は別のAPIで行うようにしたかったためです。

クエリビルダーの実装に関しては以下のドキュメントを参照してください。

https://takapi327.github.io/ldbc/ja/03-Type-safe-Query-Builder.html

### SchemaSPYの統合：テーブル記述からドキュメントを生成する

LDBCは、テーブル定義からSchemaSPYの仕様書を自動生成することができます。
これはもう一つの何かの処理（“How”）です。

[SchemaSPY](https://schemaspy.org/)は、データベースのスキーマを解析し、HTMLやPDFなどの形式でドキュメントを生成する非常に優れたツールです。

LDBCはこのSchemaSPYを使用してテーブル定義からドキュメントを自動生成することができます。

純粋なSchemaSPYを使用した場合との違いは、LDBCではドキュメントを生成するためにデータベースに接続する必要がないということです。
データベースを使用しない利点としては、ドキュメントを生成するためにデータベースを構築する必要がないという点と純粋にデータベース接続は重たい処理なのでそこを省くことができるという点です。

SchemaSPYのドキュメントは非常に見やすく、テーブルの詳細な情報を提供してくれています。
しかしこのドキュメントを生成するためには、まずデータベースを構築しないといけません。
筆者の個人的な意見としては、データベースを構築する前にドキュメントを生成しリレーションなどを確認することで設計に問題がないかを確認し、修正があれば正規化を行う。
そして問題がないとわかった時点でデータベースを構築するという流れが理想だと思っています。

なので、SchemaSPYを使用する場合にはデータベースを構築しないといけないという点が少し不便だと感じていました。
LDBCを使用することで、このようなデータベースに接続するための情報を持っていなくてもドキュメントを生成することができるため、開発者がデータベースのスキーマを管理する上での負担を軽減することができます。

具体的な実装方法に関しては以下のドキュメントを参照してください。

https://takapi327.github.io/ldbc/ja/06-Generating-SchemaSPY-Documentation.html

## 技術的な挑戦と解決策
## 使い方と実装のガイド
